{"ast":null,"code":"import EventEmitter from 'eventemitter3';\nexport { EventEmitter };\n/**\n * A wallet's readiness describes a series of states that the wallet can be in,\n * depending on what kind of wallet it is. An installable wallet (eg. a browser\n * extension like Phantom) might be `Installed` if we've found the Phantom API\n * in the global scope, or `NotDetected` otherwise. A loadable, zero-install\n * runtime (eg. Torus Wallet) might simply signal that it's `Loadable`. Use this\n * metadata to personalize the wallet list for each user (eg. to show their\n * installed wallets first).\n */\n\nexport var WalletReadyState;\n\n(function (WalletReadyState) {\n  /**\n   * User-installable wallets can typically be detected by scanning for an API\n   * that they've injected into the global context. If such an API is present,\n   * we consider the wallet to have been installed.\n   */\n  WalletReadyState[\"Installed\"] = \"Installed\";\n  WalletReadyState[\"NotDetected\"] = \"NotDetected\";\n  /**\n   * Loadable wallets are always available to you. Since you can load them at\n   * any time, it's meaningless to say that they have been detected.\n   */\n\n  WalletReadyState[\"Loadable\"] = \"Loadable\";\n  /**\n   * If a wallet is not supported on a given platform (eg. server-rendering, or\n   * mobile) then it will stay in the `Unsupported` state.\n   */\n\n  WalletReadyState[\"Unsupported\"] = \"Unsupported\";\n})(WalletReadyState || (WalletReadyState = {}));\n\nexport class BaseWalletAdapter extends EventEmitter {\n  get connected() {\n    return !!this.publicKey;\n  }\n\n}\nexport function scopePollingDetectionStrategy(detect) {\n  // Early return when server-side rendering\n  if (typeof window === 'undefined' || typeof document === 'undefined') return;\n  const disposers = [];\n\n  function detectAndDispose() {\n    const detected = detect();\n\n    if (detected) {\n      for (const dispose of disposers) {\n        dispose();\n      }\n    }\n  } // Strategy #1: Try detecting every second.\n\n\n  const interval = // TODO: #334 Replace with idle callback strategy.\n  setInterval(detectAndDispose, 1000);\n  disposers.push(() => clearInterval(interval)); // Strategy #2: Detect as soon as the DOM becomes 'ready'/'interactive'.\n\n  if ( // Implies that `DOMContentLoaded` has not yet fired.\n  document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', detectAndDispose, {\n      once: true\n    });\n    disposers.push(() => document.removeEventListener('DOMContentLoaded', detectAndDispose));\n  } // Strategy #3: Detect after the `window` has fully loaded.\n\n\n  if ( // If the `complete` state has been reached, we're too late.\n  document.readyState !== 'complete') {\n    window.addEventListener('load', detectAndDispose, {\n      once: true\n    });\n    disposers.push(() => window.removeEventListener('load', detectAndDispose));\n  } // Strategy #4: Detect synchronously, now.\n\n\n  detectAndDispose();\n}","map":{"version":3,"mappings":"AACA,OAAOA,YAAP,MAAyB,eAAzB;AAGA,SAASA,YAAT;AAqCA;;;;;;;;;;AASA,WAAYC,gBAAZ;;AAAA,WAAYA,gBAAZ,EAA4B;AACxB;;;;;AAKAA;AACAA;AACA;;;;;AAIAA;AACA;;;;;AAIAA;AACH,CAlBD,EAAYA,gBAAgB,KAAhBA,gBAAgB,MAA5B;;AAoBA,OAAM,MAAgBC,iBAAhB,SAA0CF,YAA1C,CAA2E;AAQhE,MAATG,SAAS;AACT,WAAO,CAAC,CAAC,KAAKC,SAAd;AACH;;AAV4E;AAqBjF,OAAM,SAAUC,6BAAV,CAAwCC,MAAxC,EAA6D;AAC/D;AACA,MAAI,OAAOC,MAAP,KAAkB,WAAlB,IAAiC,OAAOC,QAAP,KAAoB,WAAzD,EAAsE;AAEtE,QAAMC,SAAS,GAAmB,EAAlC;;AAEA,WAASC,gBAAT,GAAyB;AACrB,UAAMC,QAAQ,GAAGL,MAAM,EAAvB;;AACA,QAAIK,QAAJ,EAAc;AACV,WAAK,MAAMC,OAAX,IAAsBH,SAAtB,EAAiC;AAC7BG,eAAO;AACV;AACJ;AACJ,GAb8D,CAe/D;;;AACA,QAAMC,QAAQ,GACV;AACAC,aAAW,CAACJ,gBAAD,EAAmB,IAAnB,CAFf;AAGAD,WAAS,CAACM,IAAV,CAAe,MAAMC,aAAa,CAACH,QAAD,CAAlC,EAnB+D,CAqB/D;;AACA,OACI;AACAL,UAAQ,CAACS,UAAT,KAAwB,SAF5B,EAGE;AACET,YAAQ,CAACU,gBAAT,CAA0B,kBAA1B,EAA8CR,gBAA9C,EAAgE;AAAES,UAAI,EAAE;AAAR,KAAhE;AACAV,aAAS,CAACM,IAAV,CAAe,MAAMP,QAAQ,CAACY,mBAAT,CAA6B,kBAA7B,EAAiDV,gBAAjD,CAArB;AACH,GA5B8D,CA8B/D;;;AACA,OACI;AACAF,UAAQ,CAACS,UAAT,KAAwB,UAF5B,EAGE;AACEV,UAAM,CAACW,gBAAP,CAAwB,MAAxB,EAAgCR,gBAAhC,EAAkD;AAAES,UAAI,EAAE;AAAR,KAAlD;AACAV,aAAS,CAACM,IAAV,CAAe,MAAMR,MAAM,CAACa,mBAAP,CAA2B,MAA3B,EAAmCV,gBAAnC,CAArB;AACH,GArC8D,CAuC/D;;;AACAA,kBAAgB;AACnB","names":["EventEmitter","WalletReadyState","BaseWalletAdapter","connected","publicKey","scopePollingDetectionStrategy","detect","window","document","disposers","detectAndDispose","detected","dispose","interval","setInterval","push","clearInterval","readyState","addEventListener","once","removeEventListener"],"sources":["/Users/bryan/solana-crowdfunding/.yarn/cache/@solana-wallet-adapter-base-npm-0.9.5-2cb785cdd6-c40507779f.zip/node_modules/@solana/wallet-adapter-base/src/adapter.ts"],"sourcesContent":["import { Connection, PublicKey, SendOptions, Signer, Transaction, TransactionSignature } from '@solana/web3.js';\nimport EventEmitter from 'eventemitter3';\nimport { WalletError } from './errors';\n\nexport { EventEmitter };\n\nexport interface WalletAdapterEvents {\n    connect(publicKey: PublicKey): void;\n    disconnect(): void;\n    error(error: WalletError): void;\n    readyStateChange(readyState: WalletReadyState): void;\n}\n\nexport interface SendTransactionOptions extends SendOptions {\n    signers?: Signer[];\n}\n\n// WalletName is a nominal type that wallet adapters should use, e.g. `'MyCryptoWallet' as WalletName`\n// https://medium.com/@KevinBGreene/surviving-the-typescript-ecosystem-branding-and-type-tagging-6cf6e516523d\nexport type WalletName = string & { __brand__: 'WalletName' };\n\nexport interface WalletAdapterProps {\n    name: WalletName;\n    url: string;\n    icon: string;\n    readyState: WalletReadyState;\n    publicKey: PublicKey | null;\n    connecting: boolean;\n    connected: boolean;\n\n    connect(): Promise<void>;\n    disconnect(): Promise<void>;\n    sendTransaction(\n        transaction: Transaction,\n        connection: Connection,\n        options?: SendTransactionOptions\n    ): Promise<TransactionSignature>;\n}\n\nexport type WalletAdapter = WalletAdapterProps & EventEmitter<WalletAdapterEvents>;\n\n/**\n * A wallet's readiness describes a series of states that the wallet can be in,\n * depending on what kind of wallet it is. An installable wallet (eg. a browser\n * extension like Phantom) might be `Installed` if we've found the Phantom API\n * in the global scope, or `NotDetected` otherwise. A loadable, zero-install\n * runtime (eg. Torus Wallet) might simply signal that it's `Loadable`. Use this\n * metadata to personalize the wallet list for each user (eg. to show their\n * installed wallets first).\n */\nexport enum WalletReadyState {\n    /**\n     * User-installable wallets can typically be detected by scanning for an API\n     * that they've injected into the global context. If such an API is present,\n     * we consider the wallet to have been installed.\n     */\n    Installed = 'Installed',\n    NotDetected = 'NotDetected',\n    /**\n     * Loadable wallets are always available to you. Since you can load them at\n     * any time, it's meaningless to say that they have been detected.\n     */\n    Loadable = 'Loadable',\n    /**\n     * If a wallet is not supported on a given platform (eg. server-rendering, or\n     * mobile) then it will stay in the `Unsupported` state.\n     */\n    Unsupported = 'Unsupported',\n}\n\nexport abstract class BaseWalletAdapter extends EventEmitter<WalletAdapterEvents> implements WalletAdapter {\n    abstract name: WalletName;\n    abstract url: string;\n    abstract icon: string;\n    abstract readyState: WalletReadyState;\n    abstract publicKey: PublicKey | null;\n    abstract connecting: boolean;\n\n    get connected(): boolean {\n        return !!this.publicKey;\n    }\n\n    abstract connect(): Promise<void>;\n    abstract disconnect(): Promise<void>;\n    abstract sendTransaction(\n        transaction: Transaction,\n        connection: Connection,\n        options?: SendTransactionOptions\n    ): Promise<TransactionSignature>;\n}\n\nexport function scopePollingDetectionStrategy(detect: () => boolean): void {\n    // Early return when server-side rendering\n    if (typeof window === 'undefined' || typeof document === 'undefined') return;\n\n    const disposers: (() => void)[] = [];\n\n    function detectAndDispose() {\n        const detected = detect();\n        if (detected) {\n            for (const dispose of disposers) {\n                dispose();\n            }\n        }\n    }\n\n    // Strategy #1: Try detecting every second.\n    const interval =\n        // TODO: #334 Replace with idle callback strategy.\n        setInterval(detectAndDispose, 1000);\n    disposers.push(() => clearInterval(interval));\n\n    // Strategy #2: Detect as soon as the DOM becomes 'ready'/'interactive'.\n    if (\n        // Implies that `DOMContentLoaded` has not yet fired.\n        document.readyState === 'loading'\n    ) {\n        document.addEventListener('DOMContentLoaded', detectAndDispose, { once: true });\n        disposers.push(() => document.removeEventListener('DOMContentLoaded', detectAndDispose));\n    }\n\n    // Strategy #3: Detect after the `window` has fully loaded.\n    if (\n        // If the `complete` state has been reached, we're too late.\n        document.readyState !== 'complete'\n    ) {\n        window.addEventListener('load', detectAndDispose, { once: true });\n        disposers.push(() => window.removeEventListener('load', detectAndDispose));\n    }\n\n    // Strategy #4: Detect synchronously, now.\n    detectAndDispose();\n}\n"]},"metadata":{},"sourceType":"module"}