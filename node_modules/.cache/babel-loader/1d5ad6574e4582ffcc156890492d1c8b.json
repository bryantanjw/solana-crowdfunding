{"ast":null,"code":"/**\n * this is a set which automatically forgets\n * a given entry when a new entry is set and the ttl\n * of the old one is over\n */\nvar ObliviousSet =\n/** @class */\nfunction () {\n  function ObliviousSet(ttl) {\n    this.ttl = ttl;\n    this.set = new Set();\n    this.timeMap = new Map();\n  }\n\n  ObliviousSet.prototype.has = function (value) {\n    return this.set.has(value);\n  };\n\n  ObliviousSet.prototype.add = function (value) {\n    var _this = this;\n\n    this.timeMap.set(value, now());\n    this.set.add(value);\n    /**\n     * When a new value is added,\n     * start the cleanup at the next tick\n     * to not block the cpu for more important stuff\n     * that might happen.\n     */\n\n    setTimeout(function () {\n      removeTooOldValues(_this);\n    }, 0);\n  };\n\n  ObliviousSet.prototype.clear = function () {\n    this.set.clear();\n    this.timeMap.clear();\n  };\n\n  return ObliviousSet;\n}();\n\nexport { ObliviousSet };\n/**\n * Removes all entries from the set\n * where the TTL has expired\n */\n\nexport function removeTooOldValues(obliviousSet) {\n  var olderThen = now() - obliviousSet.ttl;\n  var iterator = obliviousSet.set[Symbol.iterator]();\n  /**\n   * Because we can assume the new values are added at the bottom,\n   * we start from the top and stop as soon as we reach a non-too-old value.\n   */\n\n  while (true) {\n    var value = iterator.next().value;\n\n    if (!value) {\n      return; // no more elements\n    }\n\n    var time = obliviousSet.timeMap.get(value);\n\n    if (time < olderThen) {\n      obliviousSet.timeMap.delete(value);\n      obliviousSet.set.delete(value);\n    } else {\n      // We reached a value that is not old enough\n      return;\n    }\n  }\n}\nexport function now() {\n  return new Date().getTime();\n}","map":{"version":3,"mappings":"AACA;;;;;AAKA;AAAA;AAAA;AAGI,wBACoBA,GADpB,EAC+B;AAAX;AAHJ,eAAM,IAAIC,GAAJ,EAAN;AACA,mBAAU,IAAIC,GAAJ,EAAV;AAGX;;AAELC,yCAAIC,KAAJ,EAAY;AACR,WAAO,KAAKC,GAAL,CAASC,GAAT,CAAaF,KAAb,CAAP;AACH,GAFD;;AAIAD,yCAAIC,KAAJ,EAAY;AAAZ;;AACI,SAAKG,OAAL,CAAaF,GAAb,CAAiBD,KAAjB,EAAwBI,GAAG,EAA3B;AACA,SAAKH,GAAL,CAASI,GAAT,CAAaL,KAAb;AAEA;;;;;;;AAMAM,cAAU,CAAC;AACPC,wBAAkB,CAACC,KAAD,CAAlB;AACH,KAFS,EAEP,CAFO,CAAV;AAGH,GAbD;;AAeAT;AACI,SAAKE,GAAL,CAASQ,KAAT;AACA,SAAKN,OAAL,CAAaM,KAAb;AACH,GAHD;;AAIJ;AAAC,CA9BD;;;AAiCA;;;;;AAIA,OAAM,SAAUF,kBAAV,CACFG,YADE,EACwB;AAE1B,MAAMC,SAAS,GAAGP,GAAG,KAAKM,YAAY,CAACd,GAAvC;AACA,MAAMgB,QAAQ,GAAGF,YAAY,CAACT,GAAb,CAAiBY,MAAM,CAACD,QAAxB,GAAjB;AAEA;;;;;AAIA,SAAO,IAAP,EAAa;AACT,QAAMZ,KAAK,GAAGY,QAAQ,CAACE,IAAT,GAAgBd,KAA9B;;AACA,QAAI,CAACA,KAAL,EAAY;AACR,aADQ,CACA;AACX;;AACD,QAAMe,IAAI,GAAGL,YAAY,CAACP,OAAb,CAAqBa,GAArB,CAAyBhB,KAAzB,CAAb;;AACA,QAAIe,IAAI,GAAGJ,SAAX,EAAsB;AAClBD,kBAAY,CAACP,OAAb,CAAqBc,MAArB,CAA4BjB,KAA5B;AACAU,kBAAY,CAACT,GAAb,CAAiBgB,MAAjB,CAAwBjB,KAAxB;AACH,KAHD,MAGO;AACH;AACA;AACH;AACJ;AACJ;AAED,OAAM,SAAUI,GAAV,GAAa;AACf,SAAO,IAAIc,IAAJ,GAAWC,OAAX,EAAP;AACH","names":["ttl","Set","Map","ObliviousSet","value","set","has","timeMap","now","add","setTimeout","removeTooOldValues","_this","clear","obliviousSet","olderThen","iterator","Symbol","next","time","get","delete","Date","getTime"],"sources":["/Users/bryan/solana-crowdfunding/.yarn/cache/oblivious-set-npm-1.0.0-8e7336b241-f31740ea9c.zip/node_modules/oblivious-set/src/index.ts"],"sourcesContent":["\n/**\n * this is a set which automatically forgets\n * a given entry when a new entry is set and the ttl\n * of the old one is over\n */\nexport class ObliviousSet<T = any> {\n    public readonly set = new Set();\n    public readonly timeMap = new Map();\n    constructor(\n        public readonly ttl: number\n    ) { }\n\n    has(value: T): boolean {\n        return this.set.has(value);\n    }\n\n    add(value: T): void {\n        this.timeMap.set(value, now());\n        this.set.add(value);\n\n        /**\n         * When a new value is added,\n         * start the cleanup at the next tick\n         * to not block the cpu for more important stuff\n         * that might happen.\n         */\n        setTimeout(() => {\n            removeTooOldValues(this);\n        }, 0);\n    }\n\n    clear() {\n        this.set.clear();\n        this.timeMap.clear();\n    }\n}\n\n\n/**\n * Removes all entries from the set\n * where the TTL has expired\n */\nexport function removeTooOldValues(\n    obliviousSet: ObliviousSet\n) {\n    const olderThen = now() - obliviousSet.ttl;\n    const iterator = obliviousSet.set[Symbol.iterator]();\n\n    /**\n     * Because we can assume the new values are added at the bottom,\n     * we start from the top and stop as soon as we reach a non-too-old value.\n     */\n    while (true) {\n        const value = iterator.next().value;\n        if (!value) {\n            return; // no more elements\n        }\n        const time = obliviousSet.timeMap.get(value);\n        if (time < olderThen) {\n            obliviousSet.timeMap.delete(value);\n            obliviousSet.set.delete(value);\n        } else {\n            // We reached a value that is not old enough\n            return;\n        }\n    }\n}\n\nexport function now(): number {\n    return new Date().getTime();\n}\n\n\n"]},"metadata":{},"sourceType":"module"}