{"ast":null,"code":"import { WalletNotConnectedError, WalletNotReadyError, WalletReadyState } from '@solana/wallet-adapter-base';\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { WalletNotSelectedError } from './errors.mjs';\nimport { useLocalStorage } from './useLocalStorage.mjs';\nimport { WalletContext } from './useWallet.mjs';\nconst initialState = {\n  wallet: null,\n  adapter: null,\n  publicKey: null,\n  connected: false\n};\nexport const WalletProvider = _ref => {\n  let {\n    children,\n    wallets: adapters,\n    autoConnect = false,\n    onError,\n    localStorageKey = 'walletName'\n  } = _ref;\n  const [name, setName] = useLocalStorage(localStorageKey, null);\n  const [{\n    wallet,\n    adapter,\n    publicKey,\n    connected\n  }, setState] = useState(initialState);\n  const readyState = (adapter === null || adapter === void 0 ? void 0 : adapter.readyState) || WalletReadyState.Unsupported;\n  const [connecting, setConnecting] = useState(false);\n  const [disconnecting, setDisconnecting] = useState(false);\n  const isConnecting = useRef(false);\n  const isDisconnecting = useRef(false);\n  const isUnloading = useRef(false); // Wrap adapters to conform to the `Wallet` interface\n\n  const [wallets, setWallets] = useState(() => adapters.map(adapter => ({\n    adapter,\n    readyState: adapter.readyState\n  }))); // When the wallets change, start to listen for changes to their `readyState`\n\n  useEffect(() => {\n    function handleReadyStateChange(readyState) {\n      setWallets(prevWallets => {\n        const walletIndex = prevWallets.findIndex(_ref2 => {\n          let {\n            adapter\n          } = _ref2;\n          return adapter.name === this.name;\n        });\n        if (walletIndex === -1) return prevWallets;\n        return [...prevWallets.slice(0, walletIndex), { ...prevWallets[walletIndex],\n          readyState\n        }, ...prevWallets.slice(walletIndex + 1)];\n      });\n    }\n\n    for (const adapter of adapters) {\n      adapter.on('readyStateChange', handleReadyStateChange, adapter);\n    }\n\n    return () => {\n      for (const adapter of adapters) {\n        adapter.off('readyStateChange', handleReadyStateChange, adapter);\n      }\n    };\n  }, [adapters]); // When the selected wallet changes, initialize the state\n\n  useEffect(() => {\n    const wallet = wallets.find(_ref3 => {\n      let {\n        adapter\n      } = _ref3;\n      return adapter.name === name;\n    });\n\n    if (wallet) {\n      setState({\n        wallet,\n        adapter: wallet.adapter,\n        connected: wallet.adapter.connected,\n        publicKey: wallet.adapter.publicKey\n      });\n    } else {\n      setState(initialState);\n    }\n  }, [name, wallets]); // If autoConnect is enabled, try to connect when the adapter changes and is ready\n\n  useEffect(() => {\n    if (isConnecting.current || connecting || connected || !autoConnect || !adapter || !(readyState === WalletReadyState.Installed || readyState === WalletReadyState.Loadable)) return;\n\n    (async function () {\n      isConnecting.current = true;\n      setConnecting(true);\n\n      try {\n        await adapter.connect();\n      } catch (error) {\n        // Clear the selected wallet\n        setName(null); // Don't throw error, but handleError will still be called\n      } finally {\n        setConnecting(false);\n        isConnecting.current = false;\n      }\n    })();\n  }, [isConnecting, connecting, connected, autoConnect, adapter, readyState]); // If the window is closing or reloading, ignore disconnect and error events from the adapter\n\n  useEffect(() => {\n    function listener() {\n      isUnloading.current = true;\n    }\n\n    window.addEventListener('beforeunload', listener);\n    return () => window.removeEventListener('beforeunload', listener);\n  }, [isUnloading]); // Handle the adapter's connect event\n\n  const handleConnect = useCallback(() => {\n    if (!adapter) return;\n    setState(state => ({ ...state,\n      connected: adapter.connected,\n      publicKey: adapter.publicKey\n    }));\n  }, [adapter]); // Handle the adapter's disconnect event\n\n  const handleDisconnect = useCallback(() => {\n    // Clear the selected wallet unless the window is unloading\n    if (!isUnloading.current) setName(null);\n  }, [isUnloading]); // Handle the adapter's error event, and local errors\n\n  const handleError = useCallback(error => {\n    // Call onError unless the window is unloading\n    if (!isUnloading.current) (onError || console.error)(error);\n    return error;\n  }, [isUnloading, onError]); // Setup and teardown event listeners when the adapter changes\n\n  useEffect(() => {\n    if (adapter) {\n      adapter.on('connect', handleConnect);\n      adapter.on('disconnect', handleDisconnect);\n      adapter.on('error', handleError);\n      return () => {\n        adapter.off('connect', handleConnect);\n        adapter.off('disconnect', handleDisconnect);\n        adapter.off('error', handleError);\n      };\n    }\n  }, [adapter, handleConnect, handleDisconnect, handleError]); // When the adapter changes, disconnect the old one\n\n  useEffect(() => {\n    return () => {\n      adapter === null || adapter === void 0 ? void 0 : adapter.disconnect();\n    };\n  }, [adapter]); // Connect the adapter to the wallet\n\n  const connect = useCallback(async () => {\n    if (isConnecting.current || connecting || disconnecting || connected) return;\n    if (!adapter) throw handleError(new WalletNotSelectedError());\n\n    if (!(readyState === WalletReadyState.Installed || readyState === WalletReadyState.Loadable)) {\n      // Clear the selected wallet\n      setName(null);\n\n      if (typeof window !== 'undefined') {\n        window.open(adapter.url, '_blank');\n      }\n\n      throw handleError(new WalletNotReadyError());\n    }\n\n    isConnecting.current = true;\n    setConnecting(true);\n\n    try {\n      await adapter.connect();\n    } catch (error) {\n      // Clear the selected wallet\n      setName(null); // Rethrow the error, and handleError will also be called\n\n      throw error;\n    } finally {\n      setConnecting(false);\n      isConnecting.current = false;\n    }\n  }, [isConnecting, connecting, disconnecting, connected, adapter, readyState, handleError]); // Disconnect the adapter from the wallet\n\n  const disconnect = useCallback(async () => {\n    if (isDisconnecting.current || disconnecting) return;\n    if (!adapter) return setName(null);\n    isDisconnecting.current = true;\n    setDisconnecting(true);\n\n    try {\n      await adapter.disconnect();\n    } catch (error) {\n      // Clear the selected wallet\n      setName(null); // Rethrow the error, and handleError will also be called\n\n      throw error;\n    } finally {\n      setDisconnecting(false);\n      isDisconnecting.current = false;\n    }\n  }, [isDisconnecting, disconnecting, adapter]); // Send a transaction using the provided connection\n\n  const sendTransaction = useCallback(async (transaction, connection, options) => {\n    if (!adapter) throw handleError(new WalletNotSelectedError());\n    if (!connected) throw handleError(new WalletNotConnectedError());\n    return await adapter.sendTransaction(transaction, connection, options);\n  }, [adapter, handleError, connected]); // Sign a transaction if the wallet supports it\n\n  const signTransaction = useMemo(() => adapter && 'signTransaction' in adapter ? async transaction => {\n    if (!connected) throw handleError(new WalletNotConnectedError());\n    return await adapter.signTransaction(transaction);\n  } : undefined, [adapter, handleError, connected]); // Sign multiple transactions if the wallet supports it\n\n  const signAllTransactions = useMemo(() => adapter && 'signAllTransactions' in adapter ? async transactions => {\n    if (!connected) throw handleError(new WalletNotConnectedError());\n    return await adapter.signAllTransactions(transactions);\n  } : undefined, [adapter, handleError, connected]); // Sign an arbitrary message if the wallet supports it\n\n  const signMessage = useMemo(() => adapter && 'signMessage' in adapter ? async message => {\n    if (!connected) throw handleError(new WalletNotConnectedError());\n    return await adapter.signMessage(message);\n  } : undefined, [adapter, handleError, connected]);\n  return React.createElement(WalletContext.Provider, {\n    value: {\n      autoConnect,\n      wallets,\n      wallet,\n      publicKey,\n      connected,\n      connecting,\n      disconnecting,\n      select: setName,\n      connect,\n      disconnect,\n      sendTransaction,\n      signTransaction,\n      signAllTransactions,\n      signMessage\n    }\n  }, children);\n};","map":{"version":3,"mappings":"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","names":["WalletNotConnectedError","WalletNotReadyError","WalletReadyState","React","useCallback","useEffect","useMemo","useRef","useState","WalletNotSelectedError","useLocalStorage","WalletContext","initialState","wallet","adapter","publicKey","connected","WalletProvider","children","wallets","adapters","autoConnect","onError","localStorageKey","name","setName","setState","readyState","Unsupported","connecting","setConnecting","disconnecting","setDisconnecting","isConnecting","isDisconnecting","isUnloading","setWallets","map","handleReadyStateChange","prevWallets","walletIndex","findIndex","slice","on","off","find","current","Installed","Loadable","connect","error","listener","window","addEventListener","removeEventListener","handleConnect","state","handleDisconnect","handleError","console","disconnect","open","url","sendTransaction","transaction","connection","options","signTransaction","undefined","signAllTransactions","transactions","signMessage","message","Provider","value","select"],"sources":["/Users/bryan/solana-crowdfunding/.yarn/__virtual__/@solana-wallet-adapter-react-virtual-90c353b872/0/cache/@solana-wallet-adapter-react-npm-0.15.4-23181de976-38c9e66ef3.zip/node_modules/@solana/wallet-adapter-react/src/WalletProvider.tsx"],"sourcesContent":["import {\n    Adapter,\n    SendTransactionOptions,\n    WalletError,\n    WalletName,\n    WalletNotConnectedError,\n    WalletNotReadyError,\n    WalletReadyState,\n} from '@solana/wallet-adapter-base';\nimport { Connection, PublicKey, Transaction } from '@solana/web3.js';\nimport React, { FC, ReactNode, useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { WalletNotSelectedError } from './errors';\nimport { useLocalStorage } from './useLocalStorage';\nimport { Wallet, WalletContext } from './useWallet';\n\nexport interface WalletProviderProps {\n    children: ReactNode;\n    wallets: Adapter[];\n    autoConnect?: boolean;\n    onError?: (error: WalletError) => void;\n    localStorageKey?: string;\n}\n\nconst initialState: {\n    wallet: Wallet | null;\n    adapter: Adapter | null;\n    publicKey: PublicKey | null;\n    connected: boolean;\n} = {\n    wallet: null,\n    adapter: null,\n    publicKey: null,\n    connected: false,\n};\n\nexport const WalletProvider: FC<WalletProviderProps> = ({\n    children,\n    wallets: adapters,\n    autoConnect = false,\n    onError,\n    localStorageKey = 'walletName',\n}) => {\n    const [name, setName] = useLocalStorage<WalletName | null>(localStorageKey, null);\n    const [{ wallet, adapter, publicKey, connected }, setState] = useState(initialState);\n    const readyState = adapter?.readyState || WalletReadyState.Unsupported;\n    const [connecting, setConnecting] = useState(false);\n    const [disconnecting, setDisconnecting] = useState(false);\n    const isConnecting = useRef(false);\n    const isDisconnecting = useRef(false);\n    const isUnloading = useRef(false);\n\n    // Wrap adapters to conform to the `Wallet` interface\n    const [wallets, setWallets] = useState(() =>\n        adapters.map((adapter) => ({\n            adapter,\n            readyState: adapter.readyState,\n        }))\n    );\n\n    // When the wallets change, start to listen for changes to their `readyState`\n    useEffect(() => {\n        function handleReadyStateChange(this: Adapter, readyState: WalletReadyState) {\n            setWallets((prevWallets) => {\n                const walletIndex = prevWallets.findIndex(({ adapter }) => adapter.name === this.name);\n                if (walletIndex === -1) return prevWallets;\n\n                return [\n                    ...prevWallets.slice(0, walletIndex),\n                    { ...prevWallets[walletIndex], readyState },\n                    ...prevWallets.slice(walletIndex + 1),\n                ];\n            });\n        }\n        for (const adapter of adapters) {\n            adapter.on('readyStateChange', handleReadyStateChange, adapter);\n        }\n        return () => {\n            for (const adapter of adapters) {\n                adapter.off('readyStateChange', handleReadyStateChange, adapter);\n            }\n        };\n    }, [adapters]);\n\n    // When the selected wallet changes, initialize the state\n    useEffect(() => {\n        const wallet = wallets.find(({ adapter }) => adapter.name === name);\n        if (wallet) {\n            setState({\n                wallet,\n                adapter: wallet.adapter,\n                connected: wallet.adapter.connected,\n                publicKey: wallet.adapter.publicKey,\n            });\n        } else {\n            setState(initialState);\n        }\n    }, [name, wallets]);\n\n    // If autoConnect is enabled, try to connect when the adapter changes and is ready\n    useEffect(() => {\n        if (\n            isConnecting.current ||\n            connecting ||\n            connected ||\n            !autoConnect ||\n            !adapter ||\n            !(readyState === WalletReadyState.Installed || readyState === WalletReadyState.Loadable)\n        )\n            return;\n\n        (async function () {\n            isConnecting.current = true;\n            setConnecting(true);\n            try {\n                await adapter.connect();\n            } catch (error: any) {\n                // Clear the selected wallet\n                setName(null);\n                // Don't throw error, but handleError will still be called\n            } finally {\n                setConnecting(false);\n                isConnecting.current = false;\n            }\n        })();\n    }, [isConnecting, connecting, connected, autoConnect, adapter, readyState]);\n\n    // If the window is closing or reloading, ignore disconnect and error events from the adapter\n    useEffect(() => {\n        function listener() {\n            isUnloading.current = true;\n        }\n\n        window.addEventListener('beforeunload', listener);\n        return () => window.removeEventListener('beforeunload', listener);\n    }, [isUnloading]);\n\n    // Handle the adapter's connect event\n    const handleConnect = useCallback(() => {\n        if (!adapter) return;\n        setState((state) => ({ ...state, connected: adapter.connected, publicKey: adapter.publicKey }));\n    }, [adapter]);\n\n    // Handle the adapter's disconnect event\n    const handleDisconnect = useCallback(() => {\n        // Clear the selected wallet unless the window is unloading\n        if (!isUnloading.current) setName(null);\n    }, [isUnloading]);\n\n    // Handle the adapter's error event, and local errors\n    const handleError = useCallback(\n        (error: WalletError) => {\n            // Call onError unless the window is unloading\n            if (!isUnloading.current) (onError || console.error)(error);\n            return error;\n        },\n        [isUnloading, onError]\n    );\n\n    // Setup and teardown event listeners when the adapter changes\n    useEffect(() => {\n        if (adapter) {\n            adapter.on('connect', handleConnect);\n            adapter.on('disconnect', handleDisconnect);\n            adapter.on('error', handleError);\n            return () => {\n                adapter.off('connect', handleConnect);\n                adapter.off('disconnect', handleDisconnect);\n                adapter.off('error', handleError);\n            };\n        }\n    }, [adapter, handleConnect, handleDisconnect, handleError]);\n\n    // When the adapter changes, disconnect the old one\n    useEffect(() => {\n        return () => {\n            adapter?.disconnect();\n        };\n    }, [adapter]);\n\n    // Connect the adapter to the wallet\n    const connect = useCallback(async () => {\n        if (isConnecting.current || connecting || disconnecting || connected) return;\n        if (!adapter) throw handleError(new WalletNotSelectedError());\n\n        if (!(readyState === WalletReadyState.Installed || readyState === WalletReadyState.Loadable)) {\n            // Clear the selected wallet\n            setName(null);\n\n            if (typeof window !== 'undefined') {\n                window.open(adapter.url, '_blank');\n            }\n\n            throw handleError(new WalletNotReadyError());\n        }\n\n        isConnecting.current = true;\n        setConnecting(true);\n        try {\n            await adapter.connect();\n        } catch (error: any) {\n            // Clear the selected wallet\n            setName(null);\n            // Rethrow the error, and handleError will also be called\n            throw error;\n        } finally {\n            setConnecting(false);\n            isConnecting.current = false;\n        }\n    }, [isConnecting, connecting, disconnecting, connected, adapter, readyState, handleError]);\n\n    // Disconnect the adapter from the wallet\n    const disconnect = useCallback(async () => {\n        if (isDisconnecting.current || disconnecting) return;\n        if (!adapter) return setName(null);\n\n        isDisconnecting.current = true;\n        setDisconnecting(true);\n        try {\n            await adapter.disconnect();\n        } catch (error: any) {\n            // Clear the selected wallet\n            setName(null);\n            // Rethrow the error, and handleError will also be called\n            throw error;\n        } finally {\n            setDisconnecting(false);\n            isDisconnecting.current = false;\n        }\n    }, [isDisconnecting, disconnecting, adapter]);\n\n    // Send a transaction using the provided connection\n    const sendTransaction = useCallback(\n        async (transaction: Transaction, connection: Connection, options?: SendTransactionOptions) => {\n            if (!adapter) throw handleError(new WalletNotSelectedError());\n            if (!connected) throw handleError(new WalletNotConnectedError());\n            return await adapter.sendTransaction(transaction, connection, options);\n        },\n        [adapter, handleError, connected]\n    );\n\n    // Sign a transaction if the wallet supports it\n    const signTransaction = useMemo(\n        () =>\n            adapter && 'signTransaction' in adapter\n                ? async (transaction: Transaction): Promise<Transaction> => {\n                      if (!connected) throw handleError(new WalletNotConnectedError());\n                      return await adapter.signTransaction(transaction);\n                  }\n                : undefined,\n        [adapter, handleError, connected]\n    );\n\n    // Sign multiple transactions if the wallet supports it\n    const signAllTransactions = useMemo(\n        () =>\n            adapter && 'signAllTransactions' in adapter\n                ? async (transactions: Transaction[]): Promise<Transaction[]> => {\n                      if (!connected) throw handleError(new WalletNotConnectedError());\n                      return await adapter.signAllTransactions(transactions);\n                  }\n                : undefined,\n        [adapter, handleError, connected]\n    );\n\n    // Sign an arbitrary message if the wallet supports it\n    const signMessage = useMemo(\n        () =>\n            adapter && 'signMessage' in adapter\n                ? async (message: Uint8Array): Promise<Uint8Array> => {\n                      if (!connected) throw handleError(new WalletNotConnectedError());\n                      return await adapter.signMessage(message);\n                  }\n                : undefined,\n        [adapter, handleError, connected]\n    );\n\n    return (\n        <WalletContext.Provider\n            value={{\n                autoConnect,\n                wallets,\n                wallet,\n                publicKey,\n                connected,\n                connecting,\n                disconnecting,\n                select: setName,\n                connect,\n                disconnect,\n                sendTransaction,\n                signTransaction,\n                signAllTransactions,\n                signMessage,\n            }}\n        >\n            {children}\n        </WalletContext.Provider>\n    );\n};\n"]},"metadata":{},"sourceType":"module"}