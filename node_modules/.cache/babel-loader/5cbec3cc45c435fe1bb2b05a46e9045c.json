{"ast":null,"code":"import { BaseMessageSignerWalletAdapter, scopePollingDetectionStrategy, WalletAdapterNetwork, WalletConfigError, WalletConnectionError, WalletDisconnectedError, WalletDisconnectionError, WalletError, WalletLoadError, WalletNotConnectedError, WalletNotReadyError, WalletPublicKeyError, WalletReadyState, WalletSignMessageError, WalletSignTransactionError, WalletTimeoutError, WalletWindowBlockedError, WalletWindowClosedError } from '@solana/wallet-adapter-base';\nexport class BaseSolletWalletAdapter extends BaseMessageSignerWalletAdapter {\n  constructor() {\n    let {\n      provider,\n      network = WalletAdapterNetwork.Mainnet,\n      timeout = 10000\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this._readyState = typeof window === 'undefined' || typeof document === 'undefined' ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;\n\n    this._disconnected = () => {\n      const wallet = this._wallet;\n\n      if (wallet) {\n        wallet.off('disconnect', this._disconnected);\n        this._wallet = null;\n        this.emit('error', new WalletDisconnectedError());\n        this.emit('disconnect');\n      }\n    };\n\n    this._provider = provider;\n    this._network = network;\n    this._timeout = timeout;\n    this._connecting = false;\n    this._wallet = null;\n\n    if (this._readyState !== WalletReadyState.Unsupported) {\n      if (typeof this._provider === 'string') {\n        this._readyState = WalletReadyState.Loadable;\n      } else {\n        scopePollingDetectionStrategy(() => {\n          var _a;\n\n          if (typeof ((_a = window.sollet) === null || _a === void 0 ? void 0 : _a.postMessage) === 'function') {\n            this._readyState = WalletReadyState.Installed;\n            this.emit('readyStateChange', this._readyState);\n            return true;\n          }\n\n          return false;\n        });\n      }\n    }\n  }\n\n  get publicKey() {\n    var _a;\n\n    return ((_a = this._wallet) === null || _a === void 0 ? void 0 : _a.publicKey) || null;\n  }\n\n  get connecting() {\n    return this._connecting;\n  }\n\n  get connected() {\n    var _a;\n\n    return !!((_a = this._wallet) === null || _a === void 0 ? void 0 : _a.connected);\n  }\n\n  get readyState() {\n    return this._readyState;\n  }\n\n  async connect() {\n    try {\n      if (this.connected || this.connecting) return;\n      if (!(this._readyState === WalletReadyState.Loadable || this._readyState === WalletReadyState.Installed)) throw new WalletNotReadyError();\n      this._connecting = true; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n      const provider = this._provider || window.sollet;\n      let SolWalletAdapterClass;\n\n      try {\n        ({\n          default: SolWalletAdapterClass\n        } = await import('@project-serum/sol-wallet-adapter'));\n      } catch (error) {\n        throw new WalletLoadError(error === null || error === void 0 ? void 0 : error.message, error);\n      }\n\n      let wallet;\n\n      try {\n        wallet = new SolWalletAdapterClass(provider, this._network);\n      } catch (error) {\n        throw new WalletConfigError(error === null || error === void 0 ? void 0 : error.message, error);\n      }\n\n      try {\n        // HACK: sol-wallet-adapter doesn't reject or emit an event if the popup or extension is closed or blocked\n        const handleDisconnect = wallet.handleDisconnect;\n        let timeout;\n        let interval;\n\n        try {\n          await new Promise((resolve, reject) => {\n            const connect = () => {\n              if (timeout) clearTimeout(timeout);\n              wallet.off('connect', connect);\n              resolve();\n            };\n\n            wallet.handleDisconnect = function () {\n              wallet.off('connect', connect);\n              reject(new WalletWindowClosedError());\n\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n\n              return handleDisconnect.apply(wallet, args);\n            };\n\n            wallet.on('connect', connect);\n            wallet.connect().catch(reason => {\n              wallet.off('connect', connect);\n              reject(reason);\n            });\n\n            if (typeof provider === 'string') {\n              let count = 0;\n              interval = setInterval(() => {\n                const popup = wallet._popup;\n\n                if (popup) {\n                  if (popup.closed) reject(new WalletWindowClosedError());\n                } else {\n                  if (count > 50) reject(new WalletWindowBlockedError());\n                }\n\n                count++;\n              }, 100);\n            } else {\n              // HACK: sol-wallet-adapter doesn't reject or emit an event if the extension is closed or ignored\n              timeout = setTimeout(() => reject(new WalletTimeoutError()), this._timeout);\n            }\n          });\n        } finally {\n          wallet.handleDisconnect = handleDisconnect;\n          if (interval) clearInterval(interval);\n        }\n      } catch (error) {\n        if (error instanceof WalletError) throw error;\n        throw new WalletConnectionError(error === null || error === void 0 ? void 0 : error.message, error);\n      }\n\n      if (!wallet.publicKey) throw new WalletPublicKeyError();\n      wallet.on('disconnect', this._disconnected);\n      this._wallet = wallet;\n      this.emit('connect', wallet.publicKey);\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    } finally {\n      this._connecting = false;\n    }\n  }\n\n  async disconnect() {\n    const wallet = this._wallet;\n\n    if (wallet) {\n      wallet.off('disconnect', this._disconnected);\n      this._wallet = null; // HACK: sol-wallet-adapter doesn't reliably fulfill its promise or emit an event on disconnect\n\n      const handleDisconnect = wallet.handleDisconnect;\n\n      try {\n        await new Promise((resolve, reject) => {\n          const timeout = setTimeout(() => resolve(), 250);\n\n          wallet.handleDisconnect = function () {\n            clearTimeout(timeout);\n            resolve(); // HACK: sol-wallet-adapter rejects with an uncaught promise error\n\n            wallet._responsePromises = new Map();\n\n            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              args[_key2] = arguments[_key2];\n            }\n\n            return handleDisconnect.apply(wallet, args);\n          };\n\n          wallet.disconnect().then(() => {\n            clearTimeout(timeout);\n            resolve();\n          }, error => {\n            clearTimeout(timeout); // HACK: sol-wallet-adapter rejects with an error on disconnect\n\n            if ((error === null || error === void 0 ? void 0 : error.message) === 'Wallet disconnected') {\n              resolve();\n            } else {\n              reject(error);\n            }\n          });\n        });\n      } catch (error) {\n        this.emit('error', new WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));\n      } finally {\n        wallet.handleDisconnect = handleDisconnect;\n      }\n    }\n\n    this.emit('disconnect');\n  }\n\n  async signTransaction(transaction) {\n    try {\n      const wallet = this._wallet;\n      if (!wallet) throw new WalletNotConnectedError();\n\n      try {\n        return (await wallet.signTransaction(transaction)) || transaction;\n      } catch (error) {\n        throw new WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n      }\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  async signAllTransactions(transactions) {\n    try {\n      const wallet = this._wallet;\n      if (!wallet) throw new WalletNotConnectedError();\n\n      try {\n        return (await wallet.signAllTransactions(transactions)) || transactions;\n      } catch (error) {\n        throw new WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n      }\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  async signMessage(message) {\n    try {\n      const wallet = this._wallet;\n      if (!wallet) throw new WalletNotConnectedError();\n\n      try {\n        const {\n          signature\n        } = await wallet.sign(message, 'utf8');\n        return Uint8Array.from(signature);\n      } catch (error) {\n        throw new WalletSignMessageError(error === null || error === void 0 ? void 0 : error.message, error);\n      }\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["BaseMessageSignerWalletAdapter","scopePollingDetectionStrategy","WalletAdapterNetwork","WalletConfigError","WalletConnectionError","WalletDisconnectedError","WalletDisconnectionError","WalletError","WalletLoadError","WalletNotConnectedError","WalletNotReadyError","WalletPublicKeyError","WalletReadyState","WalletSignMessageError","WalletSignTransactionError","WalletTimeoutError","WalletWindowBlockedError","WalletWindowClosedError","BaseSolletWalletAdapter","constructor","provider","network","Mainnet","timeout","window","document","Unsupported","NotDetected","wallet","_wallet","off","_disconnected","emit","_provider","_network","_timeout","_connecting","_readyState","Loadable","sollet","_a","postMessage","Installed","publicKey","connecting","connected","readyState","connect","SolWalletAdapterClass","default","error","message","handleDisconnect","interval","Promise","resolve","reject","clearTimeout","args","apply","on","catch","reason","count","setInterval","popup","_popup","closed","setTimeout","clearInterval","disconnect","_responsePromises","Map","then","signTransaction","transaction","signAllTransactions","transactions","signMessage","signature","sign","Uint8Array","from"],"sources":["/Users/bryan/solana-crowdfunding/.yarn/cache/@solana-wallet-adapter-sollet-npm-0.11.1-a385d79fa5-dd13dee884.zip/node_modules/@solana/wallet-adapter-sollet/src/base.ts"],"sourcesContent":["import type SolWalletAdapter from '@project-serum/sol-wallet-adapter';\nimport {\n    BaseMessageSignerWalletAdapter,\n    scopePollingDetectionStrategy,\n    WalletAdapterNetwork,\n    WalletConfigError,\n    WalletConnectionError,\n    WalletDisconnectedError,\n    WalletDisconnectionError,\n    WalletError,\n    WalletLoadError,\n    WalletNotConnectedError,\n    WalletNotReadyError,\n    WalletPublicKeyError,\n    WalletReadyState,\n    WalletSignMessageError,\n    WalletSignTransactionError,\n    WalletTimeoutError,\n    WalletWindowBlockedError,\n    WalletWindowClosedError,\n} from '@solana/wallet-adapter-base';\nimport { PublicKey, Transaction } from '@solana/web3.js';\n\ninterface SolletWallet {\n    postMessage(...args: unknown[]): unknown;\n}\n\ninterface SolletWindow extends Window {\n    sollet?: SolletWallet;\n}\n\ndeclare const window: SolletWindow;\n\nexport interface SolletWalletAdapterConfig {\n    provider?: string | SolletWallet;\n    network?: WalletAdapterNetwork;\n    timeout?: number;\n}\n\nexport abstract class BaseSolletWalletAdapter extends BaseMessageSignerWalletAdapter {\n    protected _provider: string | SolletWallet | undefined;\n    protected _network: WalletAdapterNetwork;\n    protected _timeout: number;\n    protected _readyState: WalletReadyState =\n        typeof window === 'undefined' || typeof document === 'undefined'\n            ? WalletReadyState.Unsupported\n            : WalletReadyState.NotDetected;\n    protected _connecting: boolean;\n    protected _wallet: SolWalletAdapter | null;\n\n    constructor({ provider, network = WalletAdapterNetwork.Mainnet, timeout = 10000 }: SolletWalletAdapterConfig = {}) {\n        super();\n\n        this._provider = provider;\n        this._network = network;\n        this._timeout = timeout;\n        this._connecting = false;\n        this._wallet = null;\n\n        if (this._readyState !== WalletReadyState.Unsupported) {\n            if (typeof this._provider === 'string') {\n                this._readyState = WalletReadyState.Loadable;\n            } else {\n                scopePollingDetectionStrategy(() => {\n                    if (typeof window.sollet?.postMessage === 'function') {\n                        this._readyState = WalletReadyState.Installed;\n                        this.emit('readyStateChange', this._readyState);\n                        return true;\n                    }\n                    return false;\n                });\n            }\n        }\n    }\n\n    get publicKey(): PublicKey | null {\n        return this._wallet?.publicKey || null;\n    }\n\n    get connecting(): boolean {\n        return this._connecting;\n    }\n\n    get connected(): boolean {\n        return !!this._wallet?.connected;\n    }\n\n    get readyState(): WalletReadyState {\n        return this._readyState;\n    }\n\n    async connect(): Promise<void> {\n        try {\n            if (this.connected || this.connecting) return;\n            if (!(this._readyState === WalletReadyState.Loadable || this._readyState === WalletReadyState.Installed))\n                throw new WalletNotReadyError();\n\n            this._connecting = true;\n\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const provider = this._provider || window!.sollet!;\n\n            let SolWalletAdapterClass: typeof SolWalletAdapter;\n            try {\n                ({ default: SolWalletAdapterClass } = await import('@project-serum/sol-wallet-adapter'));\n            } catch (error: any) {\n                throw new WalletLoadError(error?.message, error);\n            }\n\n            let wallet: SolWalletAdapter;\n            try {\n                wallet = new SolWalletAdapterClass(provider, this._network);\n            } catch (error: any) {\n                throw new WalletConfigError(error?.message, error);\n            }\n\n            try {\n                // HACK: sol-wallet-adapter doesn't reject or emit an event if the popup or extension is closed or blocked\n                const handleDisconnect: (...args: unknown[]) => unknown = (wallet as any).handleDisconnect;\n                let timeout: NodeJS.Timer | undefined;\n                let interval: NodeJS.Timer | undefined;\n                try {\n                    await new Promise<void>((resolve, reject) => {\n                        const connect = () => {\n                            if (timeout) clearTimeout(timeout);\n                            wallet.off('connect', connect);\n                            resolve();\n                        };\n\n                        (wallet as any).handleDisconnect = (...args: unknown[]): unknown => {\n                            wallet.off('connect', connect);\n                            reject(new WalletWindowClosedError());\n                            return handleDisconnect.apply(wallet, args);\n                        };\n\n                        wallet.on('connect', connect);\n\n                        wallet.connect().catch((reason: any) => {\n                            wallet.off('connect', connect);\n                            reject(reason);\n                        });\n\n                        if (typeof provider === 'string') {\n                            let count = 0;\n\n                            interval = setInterval(() => {\n                                const popup = (wallet as any)._popup;\n                                if (popup) {\n                                    if (popup.closed) reject(new WalletWindowClosedError());\n                                } else {\n                                    if (count > 50) reject(new WalletWindowBlockedError());\n                                }\n\n                                count++;\n                            }, 100);\n                        } else {\n                            // HACK: sol-wallet-adapter doesn't reject or emit an event if the extension is closed or ignored\n                            timeout = setTimeout(() => reject(new WalletTimeoutError()), this._timeout);\n                        }\n                    });\n                } finally {\n                    (wallet as any).handleDisconnect = handleDisconnect;\n                    if (interval) clearInterval(interval);\n                }\n            } catch (error: any) {\n                if (error instanceof WalletError) throw error;\n                throw new WalletConnectionError(error?.message, error);\n            }\n\n            if (!wallet.publicKey) throw new WalletPublicKeyError();\n\n            wallet.on('disconnect', this._disconnected);\n\n            this._wallet = wallet;\n\n            this.emit('connect', wallet.publicKey);\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        } finally {\n            this._connecting = false;\n        }\n    }\n\n    async disconnect(): Promise<void> {\n        const wallet = this._wallet;\n        if (wallet) {\n            wallet.off('disconnect', this._disconnected);\n\n            this._wallet = null;\n\n            // HACK: sol-wallet-adapter doesn't reliably fulfill its promise or emit an event on disconnect\n            const handleDisconnect: (...args: unknown[]) => unknown = (wallet as any).handleDisconnect;\n            try {\n                await new Promise<void>((resolve, reject) => {\n                    const timeout = setTimeout(() => resolve(), 250);\n\n                    (wallet as any).handleDisconnect = (...args: unknown[]): unknown => {\n                        clearTimeout(timeout);\n                        resolve();\n                        // HACK: sol-wallet-adapter rejects with an uncaught promise error\n                        (wallet as any)._responsePromises = new Map();\n                        return handleDisconnect.apply(wallet, args);\n                    };\n\n                    wallet.disconnect().then(\n                        () => {\n                            clearTimeout(timeout);\n                            resolve();\n                        },\n                        (error) => {\n                            clearTimeout(timeout);\n                            // HACK: sol-wallet-adapter rejects with an error on disconnect\n                            if (error?.message === 'Wallet disconnected') {\n                                resolve();\n                            } else {\n                                reject(error);\n                            }\n                        }\n                    );\n                });\n            } catch (error: any) {\n                this.emit('error', new WalletDisconnectionError(error?.message, error));\n            } finally {\n                (wallet as any).handleDisconnect = handleDisconnect;\n            }\n        }\n\n        this.emit('disconnect');\n    }\n\n    async signTransaction(transaction: Transaction): Promise<Transaction> {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new WalletNotConnectedError();\n\n            try {\n                return (await wallet.signTransaction(transaction)) || transaction;\n            } catch (error: any) {\n                throw new WalletSignTransactionError(error?.message, error);\n            }\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        }\n    }\n\n    async signAllTransactions(transactions: Transaction[]): Promise<Transaction[]> {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new WalletNotConnectedError();\n\n            try {\n                return (await wallet.signAllTransactions(transactions)) || transactions;\n            } catch (error: any) {\n                throw new WalletSignTransactionError(error?.message, error);\n            }\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        }\n    }\n\n    async signMessage(message: Uint8Array): Promise<Uint8Array> {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new WalletNotConnectedError();\n\n            try {\n                const { signature } = await wallet.sign(message, 'utf8');\n                return Uint8Array.from(signature);\n            } catch (error: any) {\n                throw new WalletSignMessageError(error?.message, error);\n            }\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        }\n    }\n\n    private _disconnected = () => {\n        const wallet = this._wallet;\n        if (wallet) {\n            wallet.off('disconnect', this._disconnected);\n\n            this._wallet = null;\n\n            this.emit('error', new WalletDisconnectedError());\n            this.emit('disconnect');\n        }\n    };\n}\n"]},"metadata":{},"sourceType":"module"}