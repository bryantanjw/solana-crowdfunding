{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Address = void 0;\n\nvar assert_1 = __importDefault(require(\"assert\"));\n\nvar externals_1 = require(\"./externals\");\n\nvar bytes_1 = require(\"./bytes\");\n\nvar account_1 = require(\"./account\");\n\nvar Address =\n/** @class */\nfunction () {\n  function Address(buf) {\n    (0, assert_1.default)(buf.length === 20, 'Invalid address length');\n    this.buf = buf;\n  }\n  /**\n   * Returns the zero address.\n   */\n\n\n  Address.zero = function () {\n    return new Address((0, bytes_1.zeros)(20));\n  };\n  /**\n   * Returns an Address object from a hex-encoded string.\n   * @param str - Hex-encoded address\n   */\n\n\n  Address.fromString = function (str) {\n    (0, assert_1.default)((0, account_1.isValidAddress)(str), 'Invalid address');\n    return new Address((0, bytes_1.toBuffer)(str));\n  };\n  /**\n   * Returns an address for a given public key.\n   * @param pubKey The two points of an uncompressed key\n   */\n\n\n  Address.fromPublicKey = function (pubKey) {\n    (0, assert_1.default)(Buffer.isBuffer(pubKey), 'Public key should be Buffer');\n    var buf = (0, account_1.pubToAddress)(pubKey);\n    return new Address(buf);\n  };\n  /**\n   * Returns an address for a given private key.\n   * @param privateKey A private key must be 256 bits wide\n   */\n\n\n  Address.fromPrivateKey = function (privateKey) {\n    (0, assert_1.default)(Buffer.isBuffer(privateKey), 'Private key should be Buffer');\n    var buf = (0, account_1.privateToAddress)(privateKey);\n    return new Address(buf);\n  };\n  /**\n   * Generates an address for a newly created contract.\n   * @param from The address which is creating this new address\n   * @param nonce The nonce of the from account\n   */\n\n\n  Address.generate = function (from, nonce) {\n    (0, assert_1.default)(externals_1.BN.isBN(nonce));\n    return new Address((0, account_1.generateAddress)(from.buf, nonce.toArrayLike(Buffer)));\n  };\n  /**\n   * Generates an address for a contract created using CREATE2.\n   * @param from The address which is creating this new address\n   * @param salt A salt\n   * @param initCode The init code of the contract being created\n   */\n\n\n  Address.generate2 = function (from, salt, initCode) {\n    (0, assert_1.default)(Buffer.isBuffer(salt));\n    (0, assert_1.default)(Buffer.isBuffer(initCode));\n    return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));\n  };\n  /**\n   * Is address equal to another.\n   */\n\n\n  Address.prototype.equals = function (address) {\n    return this.buf.equals(address.buf);\n  };\n  /**\n   * Is address zero.\n   */\n\n\n  Address.prototype.isZero = function () {\n    return this.equals(Address.zero());\n  };\n  /**\n   * True if address is in the address range defined\n   * by EIP-1352\n   */\n\n\n  Address.prototype.isPrecompileOrSystemAddress = function () {\n    var addressBN = new externals_1.BN(this.buf);\n    var rangeMin = new externals_1.BN(0);\n    var rangeMax = new externals_1.BN('ffff', 'hex');\n    return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);\n  };\n  /**\n   * Returns hex encoding of address.\n   */\n\n\n  Address.prototype.toString = function () {\n    return '0x' + this.buf.toString('hex');\n  };\n  /**\n   * Returns Buffer representation of address.\n   */\n\n\n  Address.prototype.toBuffer = function () {\n    return Buffer.from(this.buf);\n  };\n\n  return Address;\n}();\n\nexports.Address = Address;","map":{"version":3,"mappings":";;;;;;;;;;;;;AAAA;;AACA;;AACA;;AACA;;AAQA;AAAA;AAAA;AAGE,mBAAYA,GAAZ,EAAuB;AACrB,0BAAOA,GAAG,CAACC,MAAJ,KAAe,EAAtB,EAA0B,wBAA1B;AACA,SAAKD,GAAL,GAAWA,GAAX;AACD;AAED;;;;;AAGOE,iBAAP;AACE,WAAO,IAAIA,OAAJ,CAAY,mBAAM,EAAN,CAAZ,CAAP;AACD,GAFM;AAIP;;;;;;AAIOA,uBAAP,UAAkBC,GAAlB,EAA6B;AAC3B,0BAAO,8BAAeA,GAAf,CAAP,EAA4B,iBAA5B;AACA,WAAO,IAAID,OAAJ,CAAY,sBAASC,GAAT,CAAZ,CAAP;AACD,GAHM;AAKP;;;;;;AAIOD,0BAAP,UAAqBE,MAArB,EAAmC;AACjC,0BAAOC,MAAM,CAACC,QAAP,CAAgBF,MAAhB,CAAP,EAAgC,6BAAhC;AACA,QAAMJ,GAAG,GAAG,4BAAaI,MAAb,CAAZ;AACA,WAAO,IAAIF,OAAJ,CAAYF,GAAZ,CAAP;AACD,GAJM;AAMP;;;;;;AAIOE,2BAAP,UAAsBK,UAAtB,EAAwC;AACtC,0BAAOF,MAAM,CAACC,QAAP,CAAgBC,UAAhB,CAAP,EAAoC,8BAApC;AACA,QAAMP,GAAG,GAAG,gCAAiBO,UAAjB,CAAZ;AACA,WAAO,IAAIL,OAAJ,CAAYF,GAAZ,CAAP;AACD,GAJM;AAMP;;;;;;;AAKOE,qBAAP,UAAgBM,IAAhB,EAA+BC,KAA/B,EAAwC;AACtC,0BAAOC,eAAGC,IAAH,CAAQF,KAAR,CAAP;AACA,WAAO,IAAIP,OAAJ,CAAY,+BAAgBM,IAAI,CAACR,GAArB,EAA0BS,KAAK,CAACG,WAAN,CAAkBP,MAAlB,CAA1B,CAAZ,CAAP;AACD,GAHM;AAKP;;;;;;;;AAMOH,sBAAP,UAAiBM,IAAjB,EAAgCK,IAAhC,EAA8CC,QAA9C,EAA8D;AAC5D,0BAAOT,MAAM,CAACC,QAAP,CAAgBO,IAAhB,CAAP;AACA,0BAAOR,MAAM,CAACC,QAAP,CAAgBQ,QAAhB,CAAP;AACA,WAAO,IAAIZ,OAAJ,CAAY,gCAAiBM,IAAI,CAACR,GAAtB,EAA2Ba,IAA3B,EAAiCC,QAAjC,CAAZ,CAAP;AACD,GAJM;AAMP;;;;;AAGAZ,uCAAOa,OAAP,EAAuB;AACrB,WAAO,KAAKf,GAAL,CAASgB,MAAT,CAAgBD,OAAO,CAACf,GAAxB,CAAP;AACD,GAFD;AAIA;;;;;AAGAE;AACE,WAAO,KAAKc,MAAL,CAAYd,OAAO,CAACe,IAAR,EAAZ,CAAP;AACD,GAFD;AAIA;;;;;;AAIAf;AACE,QAAMgB,SAAS,GAAG,IAAIR,cAAJ,CAAO,KAAKV,GAAZ,CAAlB;AACA,QAAMmB,QAAQ,GAAG,IAAIT,cAAJ,CAAO,CAAP,CAAjB;AACA,QAAMU,QAAQ,GAAG,IAAIV,cAAJ,CAAO,MAAP,EAAe,KAAf,CAAjB;AAEA,WAAOQ,SAAS,CAACG,GAAV,CAAcF,QAAd,KAA2BD,SAAS,CAACI,GAAV,CAAcF,QAAd,CAAlC;AACD,GAND;AAQA;;;;;AAGAlB;AACE,WAAO,OAAO,KAAKF,GAAL,CAASuB,QAAT,CAAkB,KAAlB,CAAd;AACD,GAFD;AAIA;;;;;AAGArB;AACE,WAAOG,MAAM,CAACG,IAAP,CAAY,KAAKR,GAAjB,CAAP;AACD,GAFD;;AAGF;AAAC,CAzGD;;AAAawB","names":["buf","length","Address","str","pubKey","Buffer","isBuffer","privateKey","from","nonce","externals_1","isBN","toArrayLike","salt","initCode","address","equals","zero","addressBN","rangeMin","rangeMax","gte","lte","toString","exports"],"sources":["/Users/bryan/solana-crowdfunding/.yarn/cache/ethereumjs-util-npm-7.1.4-dd7e8a7028-ccfd9208bf.zip/node_modules/ethereumjs-util/src/address.ts"],"sourcesContent":["import assert from 'assert'\nimport { BN } from './externals'\nimport { toBuffer, zeros } from './bytes'\nimport {\n  isValidAddress,\n  pubToAddress,\n  privateToAddress,\n  generateAddress,\n  generateAddress2,\n} from './account'\n\nexport class Address {\n  public readonly buf: Buffer\n\n  constructor(buf: Buffer) {\n    assert(buf.length === 20, 'Invalid address length')\n    this.buf = buf\n  }\n\n  /**\n   * Returns the zero address.\n   */\n  static zero(): Address {\n    return new Address(zeros(20))\n  }\n\n  /**\n   * Returns an Address object from a hex-encoded string.\n   * @param str - Hex-encoded address\n   */\n  static fromString(str: string): Address {\n    assert(isValidAddress(str), 'Invalid address')\n    return new Address(toBuffer(str))\n  }\n\n  /**\n   * Returns an address for a given public key.\n   * @param pubKey The two points of an uncompressed key\n   */\n  static fromPublicKey(pubKey: Buffer): Address {\n    assert(Buffer.isBuffer(pubKey), 'Public key should be Buffer')\n    const buf = pubToAddress(pubKey)\n    return new Address(buf)\n  }\n\n  /**\n   * Returns an address for a given private key.\n   * @param privateKey A private key must be 256 bits wide\n   */\n  static fromPrivateKey(privateKey: Buffer): Address {\n    assert(Buffer.isBuffer(privateKey), 'Private key should be Buffer')\n    const buf = privateToAddress(privateKey)\n    return new Address(buf)\n  }\n\n  /**\n   * Generates an address for a newly created contract.\n   * @param from The address which is creating this new address\n   * @param nonce The nonce of the from account\n   */\n  static generate(from: Address, nonce: BN): Address {\n    assert(BN.isBN(nonce))\n    return new Address(generateAddress(from.buf, nonce.toArrayLike(Buffer)))\n  }\n\n  /**\n   * Generates an address for a contract created using CREATE2.\n   * @param from The address which is creating this new address\n   * @param salt A salt\n   * @param initCode The init code of the contract being created\n   */\n  static generate2(from: Address, salt: Buffer, initCode: Buffer): Address {\n    assert(Buffer.isBuffer(salt))\n    assert(Buffer.isBuffer(initCode))\n    return new Address(generateAddress2(from.buf, salt, initCode))\n  }\n\n  /**\n   * Is address equal to another.\n   */\n  equals(address: Address): boolean {\n    return this.buf.equals(address.buf)\n  }\n\n  /**\n   * Is address zero.\n   */\n  isZero(): boolean {\n    return this.equals(Address.zero())\n  }\n\n  /**\n   * True if address is in the address range defined\n   * by EIP-1352\n   */\n  isPrecompileOrSystemAddress(): boolean {\n    const addressBN = new BN(this.buf)\n    const rangeMin = new BN(0)\n    const rangeMax = new BN('ffff', 'hex')\n\n    return addressBN.gte(rangeMin) && addressBN.lte(rangeMax)\n  }\n\n  /**\n   * Returns hex encoding of address.\n   */\n  toString(): string {\n    return '0x' + this.buf.toString('hex')\n  }\n\n  /**\n   * Returns Buffer representation of address.\n   */\n  toBuffer(): Buffer {\n    return Buffer.from(this.buf)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}