{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\n\nvar errors_1 = require(\"@ledgerhq/errors\");\n\nvar Tag = 0x05;\n\nfunction asUInt16BE(value) {\n  var b = Buffer.alloc(2);\n  b.writeUInt16BE(value, 0);\n  return b;\n}\n\nvar initialAcc = {\n  data: Buffer.alloc(0),\n  dataLength: 0,\n  sequence: 0\n};\n/**\n *\n */\n\nvar createHIDframing = function (channel, packetSize) {\n  return {\n    makeBlocks: function (apdu) {\n      var data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n      var blockSize = packetSize - 5;\n      var nbBlocks = Math.ceil(data.length / blockSize);\n      data = Buffer.concat([data, Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0)]);\n      var blocks = [];\n\n      for (var i = 0; i < nbBlocks; i++) {\n        var head = Buffer.alloc(5);\n        head.writeUInt16BE(channel, 0);\n        head.writeUInt8(Tag, 2);\n        head.writeUInt16BE(i, 3);\n        var chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n        blocks.push(Buffer.concat([head, chunk]));\n      }\n\n      return blocks;\n    },\n    reduceResponse: function (acc, chunk) {\n      var _a = acc || initialAcc,\n          data = _a.data,\n          dataLength = _a.dataLength,\n          sequence = _a.sequence;\n\n      if (chunk.readUInt16BE(0) !== channel) {\n        throw new errors_1.TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n\n      if (chunk.readUInt8(2) !== Tag) {\n        throw new errors_1.TransportError(\"Invalid tag\", \"InvalidTag\");\n      }\n\n      if (chunk.readUInt16BE(3) !== sequence) {\n        throw new errors_1.TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n\n      if (!acc) {\n        dataLength = chunk.readUInt16BE(5);\n      }\n\n      sequence++;\n      var chunkData = chunk.slice(acc ? 5 : 7);\n      data = Buffer.concat([data, chunkData]);\n\n      if (data.length > dataLength) {\n        data = data.slice(0, dataLength);\n      }\n\n      return {\n        data: data,\n        dataLength: dataLength,\n        sequence: sequence\n      };\n    },\n    getReducedResult: function (acc) {\n      if (acc && acc.dataLength === acc.data.length) {\n        return acc.data;\n      }\n    }\n  };\n};\n\nexports[\"default\"] = createHIDframing;","map":{"version":3,"mappings":"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","names":["Tag","asUInt16BE","value","b","Buffer","alloc","writeUInt16BE","initialAcc","data","dataLength","sequence","createHIDframing","channel","packetSize","makeBlocks","apdu","concat","length","blockSize","nbBlocks","Math","ceil","fill","blocks","i","head","writeUInt8","chunk","slice","push","reduceResponse","acc","readUInt16BE","errors_1","readUInt8","chunkData","getReducedResult","exports"],"sources":["/Users/bryan/solana-crowdfunding/.yarn/cache/@ledgerhq-devices-npm-6.24.1-d8c83349d0-f42bce5c0d.zip/node_modules/@ledgerhq/devices/src/hid-framing.ts"],"sourcesContent":["import { TransportError } from \"@ledgerhq/errors\";\nexport type ResponseAcc =\n  | {\n      data: Buffer;\n      dataLength: number;\n      sequence: number;\n    }\n  | null\n  | undefined;\nconst Tag = 0x05;\n\nfunction asUInt16BE(value) {\n  const b = Buffer.alloc(2);\n  b.writeUInt16BE(value, 0);\n  return b;\n}\n\nconst initialAcc = {\n  data: Buffer.alloc(0),\n  dataLength: 0,\n  sequence: 0,\n};\n\n/**\n *\n */\nconst createHIDframing = (channel: number, packetSize: number) => {\n  return {\n    makeBlocks(apdu: Buffer): Buffer[] {\n      let data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n      const blockSize = packetSize - 5;\n      const nbBlocks = Math.ceil(data.length / blockSize);\n      data = Buffer.concat([\n        data, // fill data with padding\n        Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0),\n      ]);\n      const blocks: Buffer[] = [];\n\n      for (let i = 0; i < nbBlocks; i++) {\n        const head = Buffer.alloc(5);\n        head.writeUInt16BE(channel, 0);\n        head.writeUInt8(Tag, 2);\n        head.writeUInt16BE(i, 3);\n        const chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n        blocks.push(Buffer.concat([head, chunk]));\n      }\n\n      return blocks;\n    },\n\n    reduceResponse(acc: ResponseAcc, chunk: Buffer): ResponseAcc {\n      let { data, dataLength, sequence } = acc || initialAcc;\n\n      if (chunk.readUInt16BE(0) !== channel) {\n        throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n\n      if (chunk.readUInt8(2) !== Tag) {\n        throw new TransportError(\"Invalid tag\", \"InvalidTag\");\n      }\n\n      if (chunk.readUInt16BE(3) !== sequence) {\n        throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n\n      if (!acc) {\n        dataLength = chunk.readUInt16BE(5);\n      }\n\n      sequence++;\n      const chunkData = chunk.slice(acc ? 5 : 7);\n      data = Buffer.concat([data, chunkData]);\n\n      if (data.length > dataLength) {\n        data = data.slice(0, dataLength);\n      }\n\n      return {\n        data,\n        dataLength,\n        sequence,\n      };\n    },\n\n    getReducedResult(acc: ResponseAcc): Buffer | null | undefined {\n      if (acc && acc.dataLength === acc.data.length) {\n        return acc.data;\n      }\n    },\n  };\n};\n\nexport default createHIDframing;\n"]},"metadata":{},"sourceType":"script"}