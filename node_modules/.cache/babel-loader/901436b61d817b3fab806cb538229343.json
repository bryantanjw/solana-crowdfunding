{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defineProperties = void 0;\n\nvar assert_1 = __importDefault(require(\"assert\"));\n\nvar internal_1 = require(\"./internal\");\n\nvar externals_1 = require(\"./externals\");\n\nvar bytes_1 = require(\"./bytes\");\n/**\n * Defines properties on a `Object`. It make the assumption that underlying data is binary.\n * @param self the `Object` to define properties on\n * @param fields an array fields to define. Fields can contain:\n * * `name` - the name of the properties\n * * `length` - the number of bytes the field can have\n * * `allowLess` - if the field can be less than the length\n * * `allowEmpty`\n * @param data data to be validated against the definitions\n * @deprecated\n */\n\n\nvar defineProperties = function (self, fields, data) {\n  self.raw = [];\n  self._fields = []; // attach the `toJSON`\n\n  self.toJSON = function (label) {\n    if (label === void 0) {\n      label = false;\n    }\n\n    if (label) {\n      var obj_1 = {};\n\n      self._fields.forEach(function (field) {\n        obj_1[field] = \"0x\".concat(self[field].toString('hex'));\n      });\n\n      return obj_1;\n    }\n\n    return (0, bytes_1.baToJSON)(self.raw);\n  };\n\n  self.serialize = function serialize() {\n    return externals_1.rlp.encode(self.raw);\n  };\n\n  fields.forEach(function (field, i) {\n    self._fields.push(field.name);\n\n    function getter() {\n      return self.raw[i];\n    }\n\n    function setter(v) {\n      v = (0, bytes_1.toBuffer)(v);\n\n      if (v.toString('hex') === '00' && !field.allowZero) {\n        v = Buffer.allocUnsafe(0);\n      }\n\n      if (field.allowLess && field.length) {\n        v = (0, bytes_1.unpadBuffer)(v);\n        (0, assert_1.default)(field.length >= v.length, \"The field \".concat(field.name, \" must not have more \").concat(field.length, \" bytes\"));\n      } else if (!(field.allowZero && v.length === 0) && field.length) {\n        (0, assert_1.default)(field.length === v.length, \"The field \".concat(field.name, \" must have byte length of \").concat(field.length));\n      }\n\n      self.raw[i] = v;\n    }\n\n    Object.defineProperty(self, field.name, {\n      enumerable: true,\n      configurable: true,\n      get: getter,\n      set: setter\n    });\n\n    if (field.default) {\n      self[field.name] = field.default;\n    } // attach alias\n\n\n    if (field.alias) {\n      Object.defineProperty(self, field.alias, {\n        enumerable: false,\n        configurable: true,\n        set: setter,\n        get: getter\n      });\n    }\n  }); // if the constuctor is passed data\n\n  if (data) {\n    if (typeof data === 'string') {\n      data = Buffer.from((0, internal_1.stripHexPrefix)(data), 'hex');\n    }\n\n    if (Buffer.isBuffer(data)) {\n      data = externals_1.rlp.decode(data);\n    }\n\n    if (Array.isArray(data)) {\n      if (data.length > self._fields.length) {\n        throw new Error('wrong number of fields in data');\n      } // make sure all the items are buffers\n\n\n      data.forEach(function (d, i) {\n        self[self._fields[i]] = (0, bytes_1.toBuffer)(d);\n      });\n    } else if (typeof data === 'object') {\n      var keys_1 = Object.keys(data);\n      fields.forEach(function (field) {\n        if (keys_1.indexOf(field.name) !== -1) self[field.name] = data[field.name];\n        if (keys_1.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];\n      });\n    } else {\n      throw new Error('invalid data');\n    }\n  }\n};\n\nexports.defineProperties = defineProperties;","map":{"version":3,"mappings":"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","names":["defineProperties","self","fields","data","raw","_fields","toJSON","label","obj_1","forEach","field","toString","serialize","externals_1","encode","i","push","name","getter","setter","v","allowZero","Buffer","allocUnsafe","allowLess","length","concat","Object","defineProperty","enumerable","configurable","get","set","default","alias","from","isBuffer","decode","Array","isArray","Error","d","keys_1","keys","indexOf","exports"],"sources":["/Users/bryan/solana-crowdfunding/.yarn/cache/ethereumjs-util-npm-7.1.4-dd7e8a7028-ccfd9208bf.zip/node_modules/ethereumjs-util/src/object.ts"],"sourcesContent":["import assert from 'assert'\nimport { stripHexPrefix } from './internal'\nimport { rlp } from './externals'\nimport { toBuffer, baToJSON, unpadBuffer } from './bytes'\n\n/**\n * Defines properties on a `Object`. It make the assumption that underlying data is binary.\n * @param self the `Object` to define properties on\n * @param fields an array fields to define. Fields can contain:\n * * `name` - the name of the properties\n * * `length` - the number of bytes the field can have\n * * `allowLess` - if the field can be less than the length\n * * `allowEmpty`\n * @param data data to be validated against the definitions\n * @deprecated\n */\nexport const defineProperties = function (self: any, fields: any, data?: any) {\n  self.raw = []\n  self._fields = []\n\n  // attach the `toJSON`\n  self.toJSON = function (label: boolean = false) {\n    if (label) {\n      type Dict = { [key: string]: string }\n      const obj: Dict = {}\n      self._fields.forEach((field: string) => {\n        obj[field] = `0x${self[field].toString('hex')}`\n      })\n      return obj\n    }\n    return baToJSON(self.raw)\n  }\n\n  self.serialize = function serialize() {\n    return rlp.encode(self.raw)\n  }\n\n  fields.forEach((field: any, i: number) => {\n    self._fields.push(field.name)\n    function getter() {\n      return self.raw[i]\n    }\n    function setter(v: any) {\n      v = toBuffer(v)\n\n      if (v.toString('hex') === '00' && !field.allowZero) {\n        v = Buffer.allocUnsafe(0)\n      }\n\n      if (field.allowLess && field.length) {\n        v = unpadBuffer(v)\n        assert(\n          field.length >= v.length,\n          `The field ${field.name} must not have more ${field.length} bytes`\n        )\n      } else if (!(field.allowZero && v.length === 0) && field.length) {\n        assert(\n          field.length === v.length,\n          `The field ${field.name} must have byte length of ${field.length}`\n        )\n      }\n\n      self.raw[i] = v\n    }\n\n    Object.defineProperty(self, field.name, {\n      enumerable: true,\n      configurable: true,\n      get: getter,\n      set: setter,\n    })\n\n    if (field.default) {\n      self[field.name] = field.default\n    }\n\n    // attach alias\n    if (field.alias) {\n      Object.defineProperty(self, field.alias, {\n        enumerable: false,\n        configurable: true,\n        set: setter,\n        get: getter,\n      })\n    }\n  })\n\n  // if the constuctor is passed data\n  if (data) {\n    if (typeof data === 'string') {\n      data = Buffer.from(stripHexPrefix(data), 'hex')\n    }\n\n    if (Buffer.isBuffer(data)) {\n      data = rlp.decode(data)\n    }\n\n    if (Array.isArray(data)) {\n      if (data.length > self._fields.length) {\n        throw new Error('wrong number of fields in data')\n      }\n\n      // make sure all the items are buffers\n      data.forEach((d, i) => {\n        self[self._fields[i]] = toBuffer(d)\n      })\n    } else if (typeof data === 'object') {\n      const keys = Object.keys(data)\n      fields.forEach((field: any) => {\n        if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name]\n        if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias]\n      })\n    } else {\n      throw new Error('invalid data')\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}