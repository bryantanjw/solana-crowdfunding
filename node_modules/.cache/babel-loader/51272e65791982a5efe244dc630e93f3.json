{"ast":null,"code":"import { BaseMessageSignerWalletAdapter, scopePollingDetectionStrategy, WalletAccountError, WalletConnectionError, WalletDisconnectedError, WalletDisconnectionError, WalletError, WalletNotConnectedError, WalletNotReadyError, WalletPublicKeyError, WalletReadyState, WalletSignTransactionError, WalletWindowClosedError } from '@solana/wallet-adapter-base';\nimport { PublicKey } from '@solana/web3.js';\nexport const PhantomWalletName = 'Phantom';\nexport class PhantomWalletAdapter extends BaseMessageSignerWalletAdapter {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.name = PhantomWalletName;\n    this.url = 'https://phantom.app';\n    this.icon = 'data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjM0IiB3aWR0aD0iMzQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iLjUiIHgyPSIuNSIgeTE9IjAiIHkyPSIxIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiM1MzRiYjEiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM1NTFiZjkiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYiIgeDE9Ii41IiB4Mj0iLjUiIHkxPSIwIiB5Mj0iMSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZmZmIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjZmZmIiBzdG9wLW9wYWNpdHk9Ii44MiIvPjwvbGluZWFyR3JhZGllbnQ+PGNpcmNsZSBjeD0iMTciIGN5PSIxNyIgZmlsbD0idXJsKCNhKSIgcj0iMTciLz48cGF0aCBkPSJtMjkuMTcwMiAxNy4yMDcxaC0yLjk5NjljMC02LjEwNzQtNC45NjgzLTExLjA1ODE3LTExLjA5NzUtMTEuMDU4MTctNi4wNTMyNSAwLTEwLjk3NDYzIDQuODI5NTctMTEuMDk1MDggMTAuODMyMzctLjEyNDYxIDYuMjA1IDUuNzE3NTIgMTEuNTkzMiAxMS45NDUzOCAxMS41OTMyaC43ODM0YzUuNDkwNiAwIDEyLjg0OTctNC4yODI5IDEzLjk5OTUtOS41MDEzLjIxMjMtLjk2MTktLjU1MDItMS44NjYxLTEuNTM4OC0xLjg2NjF6bS0xOC41NDc5LjI3MjFjMCAuODE2Ny0uNjcwMzggMS40ODQ3LTEuNDkwMDEgMS40ODQ3LS44MTk2NCAwLTEuNDg5OTgtLjY2ODMtMS40ODk5OC0xLjQ4NDd2LTIuNDAxOWMwLS44MTY3LjY3MDM0LTEuNDg0NyAxLjQ4OTk4LTEuNDg0Ny44MTk2MyAwIDEuNDkwMDEuNjY4IDEuNDkwMDEgMS40ODQ3em01LjE3MzggMGMwIC44MTY3LS42NzAzIDEuNDg0Ny0xLjQ4OTkgMS40ODQ3LS44MTk3IDAtMS40OS0uNjY4My0xLjQ5LTEuNDg0N3YtMi40MDE5YzAtLjgxNjcuNjcwNi0xLjQ4NDcgMS40OS0xLjQ4NDcuODE5NiAwIDEuNDg5OS42NjggMS40ODk5IDEuNDg0N3oiIGZpbGw9InVybCgjYikiLz48L3N2Zz4K';\n    this._readyState = typeof window === 'undefined' || typeof document === 'undefined' ? WalletReadyState.Unsupported : WalletReadyState.NotDetected;\n\n    this._disconnected = () => {\n      const wallet = this._wallet;\n\n      if (wallet) {\n        wallet.off('disconnect', this._disconnected);\n        this._wallet = null;\n        this._publicKey = null;\n        this.emit('error', new WalletDisconnectedError());\n        this.emit('disconnect');\n      }\n    };\n\n    this._connecting = false;\n    this._wallet = null;\n    this._publicKey = null;\n\n    if (this._readyState !== WalletReadyState.Unsupported) {\n      scopePollingDetectionStrategy(() => {\n        var _a;\n\n        if ((_a = window.solana) === null || _a === void 0 ? void 0 : _a.isPhantom) {\n          this._readyState = WalletReadyState.Installed;\n          this.emit('readyStateChange', this._readyState);\n          return true;\n        }\n\n        return false;\n      });\n    }\n  }\n\n  get publicKey() {\n    return this._publicKey;\n  }\n\n  get connecting() {\n    return this._connecting;\n  }\n\n  get connected() {\n    var _a;\n\n    return !!((_a = this._wallet) === null || _a === void 0 ? void 0 : _a.isConnected);\n  }\n\n  get readyState() {\n    return this._readyState;\n  }\n\n  async connect() {\n    try {\n      if (this.connected || this.connecting) return;\n      if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();\n      this._connecting = true; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n      const wallet = window.solana;\n\n      if (!wallet.isConnected) {\n        // HACK: Phantom doesn't reject or emit an event if the popup is closed\n        const handleDisconnect = wallet._handleDisconnect;\n\n        try {\n          await new Promise((resolve, reject) => {\n            const connect = () => {\n              wallet.off('connect', connect);\n              resolve();\n            };\n\n            wallet._handleDisconnect = function () {\n              wallet.off('connect', connect);\n              reject(new WalletWindowClosedError());\n\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n\n              return handleDisconnect.apply(wallet, args);\n            };\n\n            wallet.on('connect', connect);\n            wallet.connect().catch(reason => {\n              wallet.off('connect', connect);\n              reject(reason);\n            });\n          });\n        } catch (error) {\n          if (error instanceof WalletError) throw error;\n          throw new WalletConnectionError(error === null || error === void 0 ? void 0 : error.message, error);\n        } finally {\n          wallet._handleDisconnect = handleDisconnect;\n        }\n      }\n\n      if (!wallet.publicKey) throw new WalletAccountError();\n      let publicKey;\n\n      try {\n        publicKey = new PublicKey(wallet.publicKey.toBytes());\n      } catch (error) {\n        throw new WalletPublicKeyError(error === null || error === void 0 ? void 0 : error.message, error);\n      }\n\n      wallet.on('disconnect', this._disconnected);\n      this._wallet = wallet;\n      this._publicKey = publicKey;\n      this.emit('connect', publicKey);\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    } finally {\n      this._connecting = false;\n    }\n  }\n\n  async disconnect() {\n    const wallet = this._wallet;\n\n    if (wallet) {\n      wallet.off('disconnect', this._disconnected);\n      this._wallet = null;\n      this._publicKey = null;\n\n      try {\n        await wallet.disconnect();\n      } catch (error) {\n        this.emit('error', new WalletDisconnectionError(error === null || error === void 0 ? void 0 : error.message, error));\n      }\n    }\n\n    this.emit('disconnect');\n  }\n\n  async sendTransaction(transaction, connection, options) {\n    try {\n      const wallet = this._wallet; // Phantom doesn't handle partial signers, so if they are provided, don't use `signAndSendTransaction`\n\n      if (wallet && 'signAndSendTransaction' in wallet && !(options === null || options === void 0 ? void 0 : options.signers)) {\n        // HACK: Phantom's `signAndSendTransaction` should always set these, but doesn't yet\n        transaction.feePayer = transaction.feePayer || this.publicKey || undefined;\n        transaction.recentBlockhash = transaction.recentBlockhash || (await connection.getRecentBlockhash('finalized')).blockhash;\n        const {\n          signature\n        } = await wallet.signAndSendTransaction(transaction, options);\n        return signature;\n      }\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n\n    return await super.sendTransaction(transaction, connection, options);\n  }\n\n  async signTransaction(transaction) {\n    try {\n      const wallet = this._wallet;\n      if (!wallet) throw new WalletNotConnectedError();\n\n      try {\n        return (await wallet.signTransaction(transaction)) || transaction;\n      } catch (error) {\n        throw new WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n      }\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  async signAllTransactions(transactions) {\n    try {\n      const wallet = this._wallet;\n      if (!wallet) throw new WalletNotConnectedError();\n\n      try {\n        return (await wallet.signAllTransactions(transactions)) || transactions;\n      } catch (error) {\n        throw new WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n      }\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n  async signMessage(message) {\n    try {\n      const wallet = this._wallet;\n      if (!wallet) throw new WalletNotConnectedError();\n\n      try {\n        const {\n          signature\n        } = await wallet.signMessage(message);\n        return signature;\n      } catch (error) {\n        throw new WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n      }\n    } catch (error) {\n      this.emit('error', error);\n      throw error;\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["BaseMessageSignerWalletAdapter","scopePollingDetectionStrategy","WalletAccountError","WalletConnectionError","WalletDisconnectedError","WalletDisconnectionError","WalletError","WalletNotConnectedError","WalletNotReadyError","WalletPublicKeyError","WalletReadyState","WalletSignTransactionError","WalletWindowClosedError","PublicKey","PhantomWalletName","PhantomWalletAdapter","constructor","config","window","document","Unsupported","NotDetected","wallet","_wallet","off","_disconnected","_publicKey","emit","_connecting","_readyState","solana","_a","isPhantom","Installed","publicKey","connecting","connected","isConnected","readyState","connect","handleDisconnect","_handleDisconnect","Promise","resolve","reject","args","apply","on","catch","reason","error","message","toBytes","disconnect","sendTransaction","transaction","connection","options","signers","feePayer","undefined","recentBlockhash","getRecentBlockhash","blockhash","signature","signAndSendTransaction","signTransaction","signAllTransactions","transactions","signMessage"],"sources":["/Users/bryan/solana-crowdfunding/.yarn/cache/@solana-wallet-adapter-phantom-npm-0.9.3-ed6ae17d71-c1926728e8.zip/node_modules/@solana/wallet-adapter-phantom/src/adapter.ts"],"sourcesContent":["import {\n    Adapter,\n    BaseMessageSignerWalletAdapter,\n    EventEmitter,\n    scopePollingDetectionStrategy,\n    SendTransactionOptions,\n    WalletAccountError,\n    WalletConnectionError,\n    WalletDisconnectedError,\n    WalletDisconnectionError,\n    WalletError,\n    WalletName,\n    WalletNotConnectedError,\n    WalletNotReadyError,\n    WalletPublicKeyError,\n    WalletReadyState,\n    WalletSignTransactionError,\n    WalletWindowClosedError,\n} from '@solana/wallet-adapter-base';\nimport { Connection, PublicKey, SendOptions, Transaction, TransactionSignature } from '@solana/web3.js';\n\ninterface PhantomWalletEvents {\n    connect(...args: unknown[]): unknown;\n    disconnect(...args: unknown[]): unknown;\n}\n\ninterface PhantomWallet extends EventEmitter<PhantomWalletEvents> {\n    isPhantom?: boolean;\n    publicKey?: { toBytes(): Uint8Array };\n    isConnected: boolean;\n    signTransaction(transaction: Transaction): Promise<Transaction>;\n    signAllTransactions(transactions: Transaction[]): Promise<Transaction[]>;\n    signAndSendTransaction(\n        transaction: Transaction,\n        options?: SendOptions\n    ): Promise<{ signature: TransactionSignature }>;\n    signMessage(message: Uint8Array): Promise<{ signature: Uint8Array }>;\n    connect(): Promise<void>;\n    disconnect(): Promise<void>;\n    _handleDisconnect(...args: unknown[]): unknown;\n}\n\ninterface PhantomWindow extends Window {\n    solana?: PhantomWallet;\n}\n\ndeclare const window: PhantomWindow;\n\nexport interface PhantomWalletAdapterConfig {}\n\nexport const PhantomWalletName = 'Phantom' as WalletName;\n\nexport class PhantomWalletAdapter extends BaseMessageSignerWalletAdapter {\n    name = PhantomWalletName;\n    url = 'https://phantom.app';\n    icon =\n        'data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjM0IiB3aWR0aD0iMzQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iLjUiIHgyPSIuNSIgeTE9IjAiIHkyPSIxIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiM1MzRiYjEiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM1NTFiZjkiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYiIgeDE9Ii41IiB4Mj0iLjUiIHkxPSIwIiB5Mj0iMSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZmZmIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjZmZmIiBzdG9wLW9wYWNpdHk9Ii44MiIvPjwvbGluZWFyR3JhZGllbnQ+PGNpcmNsZSBjeD0iMTciIGN5PSIxNyIgZmlsbD0idXJsKCNhKSIgcj0iMTciLz48cGF0aCBkPSJtMjkuMTcwMiAxNy4yMDcxaC0yLjk5NjljMC02LjEwNzQtNC45NjgzLTExLjA1ODE3LTExLjA5NzUtMTEuMDU4MTctNi4wNTMyNSAwLTEwLjk3NDYzIDQuODI5NTctMTEuMDk1MDggMTAuODMyMzctLjEyNDYxIDYuMjA1IDUuNzE3NTIgMTEuNTkzMiAxMS45NDUzOCAxMS41OTMyaC43ODM0YzUuNDkwNiAwIDEyLjg0OTctNC4yODI5IDEzLjk5OTUtOS41MDEzLjIxMjMtLjk2MTktLjU1MDItMS44NjYxLTEuNTM4OC0xLjg2NjF6bS0xOC41NDc5LjI3MjFjMCAuODE2Ny0uNjcwMzggMS40ODQ3LTEuNDkwMDEgMS40ODQ3LS44MTk2NCAwLTEuNDg5OTgtLjY2ODMtMS40ODk5OC0xLjQ4NDd2LTIuNDAxOWMwLS44MTY3LjY3MDM0LTEuNDg0NyAxLjQ4OTk4LTEuNDg0Ny44MTk2MyAwIDEuNDkwMDEuNjY4IDEuNDkwMDEgMS40ODQ3em01LjE3MzggMGMwIC44MTY3LS42NzAzIDEuNDg0Ny0xLjQ4OTkgMS40ODQ3LS44MTk3IDAtMS40OS0uNjY4My0xLjQ5LTEuNDg0N3YtMi40MDE5YzAtLjgxNjcuNjcwNi0xLjQ4NDcgMS40OS0xLjQ4NDcuODE5NiAwIDEuNDg5OS42NjggMS40ODk5IDEuNDg0N3oiIGZpbGw9InVybCgjYikiLz48L3N2Zz4K';\n\n    private _connecting: boolean;\n    private _wallet: PhantomWallet | null;\n    private _publicKey: PublicKey | null;\n    private _readyState: WalletReadyState =\n        typeof window === 'undefined' || typeof document === 'undefined'\n            ? WalletReadyState.Unsupported\n            : WalletReadyState.NotDetected;\n\n    constructor(config: PhantomWalletAdapterConfig = {}) {\n        super();\n        this._connecting = false;\n        this._wallet = null;\n        this._publicKey = null;\n        if (this._readyState !== WalletReadyState.Unsupported) {\n            scopePollingDetectionStrategy(() => {\n                if (window.solana?.isPhantom) {\n                    this._readyState = WalletReadyState.Installed;\n                    this.emit('readyStateChange', this._readyState);\n                    return true;\n                }\n                return false;\n            });\n        }\n    }\n\n    get publicKey(): PublicKey | null {\n        return this._publicKey;\n    }\n\n    get connecting(): boolean {\n        return this._connecting;\n    }\n\n    get connected(): boolean {\n        return !!this._wallet?.isConnected;\n    }\n\n    get readyState(): WalletReadyState {\n        return this._readyState;\n    }\n\n    async connect(): Promise<void> {\n        try {\n            if (this.connected || this.connecting) return;\n            if (this._readyState !== WalletReadyState.Installed) throw new WalletNotReadyError();\n\n            this._connecting = true;\n\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const wallet = window!.solana!;\n\n            if (!wallet.isConnected) {\n                // HACK: Phantom doesn't reject or emit an event if the popup is closed\n                const handleDisconnect = wallet._handleDisconnect;\n                try {\n                    await new Promise<void>((resolve, reject) => {\n                        const connect = () => {\n                            wallet.off('connect', connect);\n                            resolve();\n                        };\n\n                        wallet._handleDisconnect = (...args: unknown[]) => {\n                            wallet.off('connect', connect);\n                            reject(new WalletWindowClosedError());\n                            return handleDisconnect.apply(wallet, args);\n                        };\n\n                        wallet.on('connect', connect);\n\n                        wallet.connect().catch((reason: any) => {\n                            wallet.off('connect', connect);\n                            reject(reason);\n                        });\n                    });\n                } catch (error: any) {\n                    if (error instanceof WalletError) throw error;\n                    throw new WalletConnectionError(error?.message, error);\n                } finally {\n                    wallet._handleDisconnect = handleDisconnect;\n                }\n            }\n\n            if (!wallet.publicKey) throw new WalletAccountError();\n\n            let publicKey: PublicKey;\n            try {\n                publicKey = new PublicKey(wallet.publicKey.toBytes());\n            } catch (error: any) {\n                throw new WalletPublicKeyError(error?.message, error);\n            }\n\n            wallet.on('disconnect', this._disconnected);\n\n            this._wallet = wallet;\n            this._publicKey = publicKey;\n\n            this.emit('connect', publicKey);\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        } finally {\n            this._connecting = false;\n        }\n    }\n\n    async disconnect(): Promise<void> {\n        const wallet = this._wallet;\n        if (wallet) {\n            wallet.off('disconnect', this._disconnected);\n\n            this._wallet = null;\n            this._publicKey = null;\n\n            try {\n                await wallet.disconnect();\n            } catch (error: any) {\n                this.emit('error', new WalletDisconnectionError(error?.message, error));\n            }\n        }\n\n        this.emit('disconnect');\n    }\n\n    async sendTransaction(\n        transaction: Transaction,\n        connection: Connection,\n        options?: SendTransactionOptions\n    ): Promise<TransactionSignature> {\n        try {\n            const wallet = this._wallet;\n            // Phantom doesn't handle partial signers, so if they are provided, don't use `signAndSendTransaction`\n            if (wallet && 'signAndSendTransaction' in wallet && !options?.signers) {\n                // HACK: Phantom's `signAndSendTransaction` should always set these, but doesn't yet\n                transaction.feePayer = transaction.feePayer || this.publicKey || undefined;\n                transaction.recentBlockhash =\n                    transaction.recentBlockhash || (await connection.getRecentBlockhash('finalized')).blockhash;\n\n                const { signature } = await wallet.signAndSendTransaction(transaction, options);\n                return signature;\n            }\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        }\n\n        return await super.sendTransaction(transaction, connection, options);\n    }\n\n    async signTransaction(transaction: Transaction): Promise<Transaction> {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new WalletNotConnectedError();\n\n            try {\n                return (await wallet.signTransaction(transaction)) || transaction;\n            } catch (error: any) {\n                throw new WalletSignTransactionError(error?.message, error);\n            }\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        }\n    }\n\n    async signAllTransactions(transactions: Transaction[]): Promise<Transaction[]> {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new WalletNotConnectedError();\n\n            try {\n                return (await wallet.signAllTransactions(transactions)) || transactions;\n            } catch (error: any) {\n                throw new WalletSignTransactionError(error?.message, error);\n            }\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        }\n    }\n\n    async signMessage(message: Uint8Array): Promise<Uint8Array> {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new WalletNotConnectedError();\n\n            try {\n                const { signature } = await wallet.signMessage(message);\n                return signature;\n            } catch (error: any) {\n                throw new WalletSignTransactionError(error?.message, error);\n            }\n        } catch (error: any) {\n            this.emit('error', error);\n            throw error;\n        }\n    }\n\n    private _disconnected = () => {\n        const wallet = this._wallet;\n        if (wallet) {\n            wallet.off('disconnect', this._disconnected);\n\n            this._wallet = null;\n            this._publicKey = null;\n\n            this.emit('error', new WalletDisconnectedError());\n            this.emit('disconnect');\n        }\n    };\n}\n"]},"metadata":{},"sourceType":"module"}